//
//  枚举与可选类型.swift
//  SwiftTest_CommandLine
//
//  Created by ctch on 2024/3/18.
//  Copyright © 2024 com.fendaTeamIOS. All rights reserved.
//
//MARK: - 笔记
/**
    1、swift可选类型的底层是枚举类型。
        注意，枚举值是枚举值，枚举的类型结构体是类型结构体，这两是不同的概念，类型结构体的作用是创建出枚举值，而不是枚举值本身。
        可选类型，第一种可能是nil，第二种可能是该枚举值绑定的关联值。
        可选链：用于给可选类型值为nil的对象发消息。
               OC中我们给一个nil对象发送消息什么也不会发生，Swift中不能向一个 nil 对象直接发送消息，但是借助可选链可以达到类似的效果。
                也就是可以调用这个可选类型绑定的类型的方法，但是如果为nil的话，执行的结果也是nil，也就是返回值也是可选类型。
 
    2、枚举值的内存分布是最优最小的，也就是内存优化的，能存下最大那个值的内存就可以了，没必要为每一个可能的值都设置内存空间。
 
        枚举的原始值：就是计算属性(方法)，不是枚举值，枚举值表示有限的可能性，原始值只是表示该枚举值对应的方法返回什么值而已。
                    原始值其实是一个计算属性，也就是一个方法，并不占用枚举值对象的内存空间，而是放在了代码里。
                    如果不设置原始值，那么case的原始值为该case名称的字符串
 
        枚举的值：枚举的值设计用来表示可能性，所以可以是任何东西，所以也可以是函数类型的值，元组的值等等。
 
        枚举的关联值：因为枚举值是一个对象，所以也可以存储其他信息的指针。
                    在使用 switch 的时候，我们可以在 case 的后面加上 let 或者 var ，将枚举的关联值取出或者修改。
 
    3、枚举对象的内存分配：
        枚举对象占用的内存是最优化的，如果没有关联值，那么一个字节就够了，因为一个字节可以表达256中可能性了，底层只需要用这个二进制来比较就可以了。
        如果关联值是bool类型，那么枚举对象的内存就会优化，只表达128中可能性，用一个位来表示bool类型，所以内存依然是1个字节。
        如果关联值是Int类型，那么枚举对象的内存就是一个字节加一个Int类型的内存大小，9个字节，内存对齐之后就是16个字节。
        关联值占用枚举的内存，因为设置关联值为存储属性了，而原始值不占用枚举的内存，因为原始值设计为计算属性了。
 
 
 */

import Foundation
