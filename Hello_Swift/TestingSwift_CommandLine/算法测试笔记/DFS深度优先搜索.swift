//
//  DFS深度优先搜索.swift
//  SwiftTest_CommandLine
//
//  Created by ctch on 2024/3/5.
//  Copyright © 2024 com.fendaTeamIOS. All rights reserved.
//
// MARK: - 笔记
/**
    思考方向：
            该函数是返回或处理，第i步有多少种可能性，可以放哪几种牌。
            第i步遍历所有可能性，在遍历的时候用到第i+1步的结果，或说在遍历时叫第i+1步去处理，我只需要横向去处理第i步的下一个可能性。
            边界条件可以是每一次探索都到最后一步，也可以是找到目标后，设置一个flag让后面的不再继续探索。
            理解难点：已使用条件的标志数组 和 问题规模的遍历标志数组 是同一个，但是扮演了不同的角色。
                    当前层已使用的标志数组 需要释放当前层的标志，给上一层的横向使用，上一层的横向下一个需要使用的条件就是当前层的标志。
 
            问题的可重复性：使用当前条件，返回剩下规模的问题的解。
                         每一次都是使用当前条件，返回剩下问题规模的解。
                         直到问题规模为1，然后求解返回。
 
    1、深度优先，需要用到递归函数，以求全排列的思路来理解，模版为：
         void dfs(int step){
             判断边界   //如果有边界就从这里处理退出，没有边界就执行完当前递归基，执行完就是执行完了，也就是有解无解的都处理了。
                        //到这里，一条深层搜索链就完成了，也就是竖向到了最后一个位置，问题的规模到了1。可以是返回这一条竖向链，也可以是其他。
             尝试每一种可能 for(i=1;i<=n;i++){
                                //当前位置的所有可能性，这里既是当前层次的横向，也是上一层的纵向，因为i之前的都已经被标记了。
                                //这里的for循环的i有两个身份，一个是当前的横向，另一个是纵向的上一层的第i层。(都是记录数字数组的角色)
                 继续下一步 dfs(step+1)
                 }
             返回 //即退出当前递归基，返回上一层递归，但是这一层之下的递归都已经解答了，并且返回了。
         }
 
        核心在于：如何把问题理解为全排列那样去减而治之。
                重点：如果你把盒子改成竖直地放，数字数组横向插入，那就好理解很多了。
                深度竖向是全排列的盒子的位置，就是竖向的深度是确定的，也不能说是确定，只能说是边界条件，可能到达最后一个。
                横向是全排列的数字的数组，也就是当前盒子的每一种可能性数字。
 
        第一个位置用1，剩下所有位置的可能性。
        第一个位置用2，剩下所有位置的可能性。
        第一个位置。。。
        第一个位置的所用可能性用完，那么剩下所有位置的可能性也就用完了。
        全排列也就到此结束了，所以只需要处理第一个位置的所有可能性，就是所有位置的可能性了。
 
    2、深度优先搜索主要用于解决的问题：
        1，找出两个节点之间是否存在连接。
        2.穷举，找出所有可能的走法或解。如：全排列，棋类游戏。核心是减而治之，或分而治之。
        3.遍历树中的所有节点，并对其进行操作。
 
    3、标志器：
        竖放的盒子数组(边界判断，竖直深入)，横向插入的原始数字数组，
 
        1.最深已使用标志数组，需要一个标志器数组，用来记录最深的那条递归路径的当前点是否已读，不是横向，而是竖向。该数组在当前层的索引是变的。
         （与横向遍历相关）   在竖向递进中，这个数组表示的是当前层，原始数组已经被使用了多少个，判断不满足book[i]==0条件，直接从i之后开始。
                          在横向for循环中，也表示了原始数组前面的i个节点已经被使用了，直接从原始数组的i之后开始处理。
                          记得回溯的时候，需要把这个数组的当前层的标志位置零，因为上一层的横向还要用这个标志数组。
                          因为当前层是book[3] == 1,但是上一层的横向是book[2] == 1，还没走到book[3] == 0 的横向处理。
                          也就是第一个盒子还没处理放第book[3]张牌的情况，第2个盒子已经处理了放第book[3]张牌的情况。
                          当前层的book[3] = 1，是为了给下一层说我已经使用了第book[3]张牌，你要从第book[4]开始遍历可能性。
                          当前层的book[3] = 0 是为了回溯给上一层的横向使用book[3] == 0 的判断，上一层放第book[3]张牌之后的可能性。
                          但是当前层之后的竖向遍历都不会再用到，因为当前层就是上一层的第一个横向。
 
        2.最深层的结果标记数组，这个数组不是标志当前原始数组的该点是否已读，而是用来存放原始数组中的值，是结果的一截。该数组在当前层的索引是不变的。
         （与深度步数相关）    和最深已浏览数同进退，但是这里记录的是当前符合条件的值，但它也是瞬时性，也就是回溯的时候也会被赋值覆盖，
                            不是重置零，而是当前横向的时候被赋值覆盖，也就是当前层的这个节点有多少个可能性，横向。
                            因为它也是当前层的最深链的结果值。
 
        3.记录当前步数的深度链有多少条(可选)，条数数组，用一个原始数组长度的深度链条数标志数组来记录，数组的下标表示深度链的可达长度。
                                        数组的值，表示当前下标i长度的链的条数。
 
 
 */

struct TestDFSStruct{
    
    //MARK: 求解给点数组a，b，调整a的元素位置，使得a[i]>b[i]的个数尽可能多，然后有多种这种尽可能多的调整方式。
    // dfs求出a数组的全排列，然后比较b数组。
    func testDFSorder(){
        
        //1、输入a、b数组
        var aArr = readLine()!.split(separator: " ").map{Int($0)!}
        var bArr = readLine()!.split(separator: " ").map{Int($0)!}


        //2、对数组进行从小到大排序。
        var ansArr = Array(repeating: -1, count: aArr.count)    //结果链数组。
        var visitedArr = Array(repeating: false, count: aArr.count) //已使用的标记数组。
        var countArr = Array(repeating: 0, count: aArr.count + 1)   //长度为i的深度链的个数。


        //暴力遍历a数组，看最大的符合条件的有多少条。
        /**
            1、写一个暴力dfs写出a数组的全排列。
            2、每一个排列都与数组b进行比较，看每一个排列有多少个元素符合条件，找出最多符合条件的元素的排列，也就是所有最长的排列。
                用一个条数数组来记录，下标表示该深度链的长度，值表示有多少条。
         
         */

        //比较数组，看有多少个元素符合条件。
        func compareArr(inArr:[Int],refArr:[Int]){
            var count = 0   //符合要求的元素个数
            for index in 0 ..< bArr.count { //排列的长度是一样的
                let aValue = inArr[index]
                let bValue = refArr[index]
                if aValue > bValue{
                    count += 1;
                }
            }
            countArr[count] += 1;   //当前长度的深度链个数+1；
        }

        /**
            描述问题：找出a数组的全排列
            dfs函数的作用：输入当前步数，在前一步之后，当前步数有多少种可能性。把当前步数的结果输入到结果数组中。
            边界条件：走到最后一步，结果链是什么，输出每一个结果链。
         */
        /**
            1、numArr 是标志数组，也是原始数据数组。
            2、拆解问题：我给递归器输入数组中的一个数，递归器返回这个数之后的所有排列。
                        然后这些数是可解的有限范围的，也就是存在边界条件，只是每输入一个数，问题的规模就减少了1。
         */
        func dfsOrder(startIndex:Int,numArr:[Int]){
            if startIndex == numArr.count  {
                //已经走到最后一步了，处理结果链，每次到这里输出的是一个排列
                
                compareArr(inArr: ansArr, refArr: bArr) //比较元素。
                
                return
            }
            
            //遍历当前层的每一种可能性，这里整一个for循环都是标志器的作用，作是否已经使用了的标志。
            for i in 0 ..< numArr.count {
                
                if visitedArr[i] == false { //还没有使用到这个数字
                    
                    visitedArr[i] = true    //标记已经使用了第i个数字，下一层就不能再用了。
                    
                    ansArr[startIndex] = numArr[i]
                    dfsOrder(startIndex: startIndex + 1, numArr: numArr)    //处理下一步，使用下一个条件，问题规模减少1。
                    
                    visitedArr[i] = false   //释放，告诉上一层我这个牌返回牌池了。
                }
                
            }
            
        }


        dfsOrder(startIndex: 0, numArr: aArr)   //暴力dfs所有a数组的全排列

        var maxCount = 0
        for index in stride(from: bArr.count, through: 0, by: -1) {
            if countArr[index] > 0 {
                maxCount = countArr[index]
                break
            }
        }

        print("输出符合条件的数组个数：",maxCount)
    }
    
}
