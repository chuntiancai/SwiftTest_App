##  String,Array的底层

### 内存地址从低到高：
#### 代码区 --> 常量区 --> 全局区（数据段）--> 堆空间 --> 栈空间 -->  动态库

## String
###  String的内存分布
#### 0、字符串短的情况占16个字节，长的时候开辟堆空间(或_TEXT.cstring区)。
#### 1、字符串长度 <= 0xf，字符串内容直接存放在str1变量的内存中（15个字符）
#### 2、字符串长度 > 0xf，字符串内容存放在_TEXT.cstring中（常量区），该地址值就放在str2变量的后8个字节中
           _TEXT.cstring是编译时写进Mach-o的文件时的字符串(静态代码)，而不是运行时追加的字符串(动态代码)
#### 3、如果append后的字符串长度 <= 0xf，那么直接在变量的内存中进行修改
#### 4、如果append后的字符串长度 > 0xf，开辟堆空间，因为不确定以后还是否会修改(此时是堆，不是_TEXT.cstring)
   
    var str1 = "2346789dag"
        //str1占16个字节，0x6439383736343332，0xea00000000006761这两个是ascii码的值
        //0xea，其中的a是标识该字符串直接放在当前的域的地址空间，a表示字符串的长度（15个字符及以内）
        //类似oc的tagger pointer
    print(MemoryLayout.stride(ofValue: str1))
    var str2 = "096thjbijjjjjjjjjjjjjjjjjjj"
    var str3 = "234567890-0876w456790-89398479"
        //str2: rax，rdx=0xd00000000000001b,0x8000000100000f70   来自于call指令的返回值，rax，rdx，实际是调用了Swift.String.init(...)函数
        //str3: rax，rdx=0xd00000000000001e,0x8000000100000f70
        //0x8000000100000f70决定了字符串的真正地址，0x7fffffffffffffe0 + 字符串的真实地址 = 0x8000000100000f70
        //所以字符串的真实地址 = 0x8000000100000f70 - 0x7fffffffffffffe0
        //所以超过了15个字符就不是直接存在当前的域的地址空间了,所以在汇编层跟15比较决定是否调用函数
        //mov 0x7fffffffffffffe0, %rdx
    print(MemoryLayout.stride(ofValue: str2))


### dyld_stub_binder (swift中的符号绑定，符号绑定真实的内存地址，os中的概念)
#### 延迟绑定
#### stub：翻译成符号（os中的符号）
#### binder：绑定
#### 只会做一次绑定，例如绑定string.init函数，函数名就是符号，绑定就是绑定符号和真实地址（相对虚拟地址），
#### 一次绑定之后就记录下来，下次就不用再次绑定了，提高性能。


### 字面量（literal）
#### 1、如果16个字节能容下字面量，那么就会在当前地址存放该字面量，而不是区常量区或者全局区寻找，超过16个字节的话，
####        就用该16个字节存放指针，去对应的虚拟内存中寻找（_TEXT.cstring区），在mach-o文件中，在OS概念中，属于静态代码。


## Array
### Array内存
#### Array在文档上说是结构体（所以swift对Array进行了值类型的约束），但实际并不是，实际是引用类型
#### 1、一个Array变量占用8个字节，所以就不同于普通的结构体，有32个字节来存储描述信息;这8个字节存放的是堆空间的地址值
#### 2、数组中的数据存放在堆空间，在堆空间的内容分布是：
####      ？-> 引用计数 ->  元素数量 ->  数组容量？ ->  真实数据（1、2、3、4（八个字节一个））
