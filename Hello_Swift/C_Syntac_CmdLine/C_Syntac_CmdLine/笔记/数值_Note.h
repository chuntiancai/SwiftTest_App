//
//  digitSystem_Note.h
//  C_Syntac_CmdLine
//
//  Created by mathew on 2023/4/18.
//

// MARK: - 二进制的反码与补码
/**
    1、出现原因：
        计算机只适合运算加法(这样的逻辑电路最简单) --> 因为源码的符号位参与计算的话，会导致运算结果不正确,所以出现了反码 -->
        因为反码结算结果为零的时候，有两个，一个是正的零，一个是负的零，所以出现补码。而且反码只适合正数 + 负数的情况。 -->
        补码例如同余数和取模的原理，使计算结果只有一种零，而且能实现负数加负数的情况。
 
        原码：正数 + 正数。
        反码：正数 + 正数，正数 + 负数。         //计算和结果均为反码，需要转换回原码。
        补码：正数 + 正数，正数 + 负数，负数 + 负数。     //计算和结果均为补码，需要转换回原码。
 
        原码-->反码：正数不变样。负数除符号位外，其余取反。
        原码-->补码：正数不变样。负数除符号位外，其余取反 + 1。
 
        注意：正数的反码 的样子是和原码一样的。 负数的反码的样子，是原码除了符号位之后，其余数位取反。
 
        为什么 反码 + 反码 = 反码 计算出的结果是正确的原码的反码？也就是 结果反码 取反 等到的原码 是正确的数值。
               这就涉及到同等字长的二进制计算问题了，因为在同等字长的情况下(譬如大家都是8bit)，那么这两个反码的计算就涉及到了最大8bit二进制数值的限制。
            也就是，8bit 能表示最大的数目 就是9bit的10000 0000 ，即从 0000 0000 ～ 1111 1111 这个范围内，有1 0000 0000 种符号的表示。
            而你取反，就相当于在 0000 0000 ～ 1111 1111 周期内取另一半，就相当于8个苹果，你取2个，那就剩6个，你取3个，那就剩5个，就在这个周期内，刚好加起来就是
            1111 1111 。这恰好就是二进制数的特点。就你单纯把0和1当作符号看。
                假设仍然是8bit的限制，如果最高位用作符号位，那么符号的表示范围就只有7bit 000 0000 ～ 111 1111 ，因为反码只用于解决正数+ 负数的情况。
            然后反码的符号位也参与计算的原因是，不解释了，太费脑子了，下次再解释了，反正就是利用了000 0000 ～ 111 1111这个范围不断循环跑圈的原理。
        
 
    2、把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方。
       由于左移是丢弃最高位，0补最低位，所以符号位也会被丢弃，左移出来的结果值可能会改变正负性。


 */
