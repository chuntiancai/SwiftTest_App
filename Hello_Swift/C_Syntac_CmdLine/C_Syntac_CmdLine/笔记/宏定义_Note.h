//
//  宏定义_Note.h
//  C_Syntac_CmdLine
//
//  Created by mathew on 2023/5/18.
//

//MARK: - 预处理
/**
    1、什么是预处理指令:
        在我们的文件翻译成0和1之前做的操作我们称之为预处理指令，譬如把源码文件编译成链接文件时，做的一些处理。此时还没有变成可执行文件。
        一般情况预处理指令都是以#号开头的。
    2、条件编译：
        在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。
             1)按不同的条件去编译不同的程序部分,因而产生不同的目标代码文件。有利于程序的移植和调试。
             2)条件编译当然也可以用条件语句来实现。但是用条件语句将会对整个源程序进行编译,生成的目标代码程序很长,
               而采用条件编译,则根据条件只编译其中的程序段1或程序段2,生成的目标程序较短。
 
        #if-#else 条件编译指令：
            #if 条件1
                ...code1...
            #elif 条件2
                ...code2...
            #else
                ...code3...
            #endif
 
        #ifndef 条件编译指令：
            它的功能是,如果标识符未被#define命令(宏) 定义过则对程序段1进行编译,否则对程序段2进行编译。这与第二种形式的功能正相反。
                #ifndef 标识符
                    程序段1
                #else
                    程序段2
                #endif
 
        使用条件编译指令调试bug：
            #define DEBUG1 1
            #if DEBUG1 == 0 //format是格式控制,##表示可以没有参数,__VA_ARGS__表示变量
                #define Log(format,...) printf(format,## __VA_ARGS__)
            #else
                #define Log(format,...)
            #endif

            这里,‘...’指可变参数。这类宏在被调用时,##表示成零个或多个参数,包括里面的逗号,一直到到右括弧结束为止。
            当被调用时,在宏体(macro body)中,那些符号序列集合将代替里面 的VA_ARGS标识符。
            举例：
                void test(){
                    Log("xxxxx");
                }
                int main(int argc, const char * argv[]) {
                    Log("%d\n",10);
                    return 0;
                }
 */

//MARK: - 宏定义
/**
    1、被定义为“宏”的 标识符 称为“宏名”。在编译预处理时,对程序中所有出现的“宏名”,都用宏定义中的字符串去代换,这称为“宏代换”或“宏展开”。
        宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。在C语言中,“宏”分为有参数和无参数两种。
        宏会在程序翻译成二进制文件之前，将所有宏名替换成宏的值：
            源代码 --> 预处理 -->汇编 -->二进制 -->可执行程序。
        规范:
            一般情况宏名都大写, 多个单词之间用_隔开, 并且每个单词全部大写。
        注意:
            宏定义后面不要写分号。
        
        宏定义也有作用域：
            从定义的那一行开始, 一直到文件末尾
            虽然默认情况下宏定义的作用域是从定义的那一行开始, 一直到文件末尾. 但是我们也可以通过对应的关键字提前结束宏定义的作用域(#undef 宏名)。
 
    2、不带参数的宏：
        格式:
            #define 标识符 字符串
        其中的“#”表示这是一条预处理命令。凡是以“#”开头的均为预处理命令。“define”为宏定义命令。“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。
 
    3、带参数的宏定义：
        格式:
            #define 宏名(形参表) 字符串
        注意点:
            1)宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.
            2)带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。
            3)在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参。
        举例：
            #define SUM(v1, v2) v1+v2
                #define 代表要定义一个宏
                SUM 宏的名称
                (v1, v2) 参数, 注意点, 不需要写数据类型
                v1+v2 用于替换的内容
 
                宏定义并不会做任何运算, 无论是有参数还是没有参数都仅仅是在翻译成0和1之前做一个简单的"替换"
                带参数的宏定义注意点
                    1.一般情况下建议写带参数的宏的时候, 给每个参数加上一个()
                    2.一般情况下建议写带参数的宏的时候, 给结果也加上一个()
                    3.例如 #define CF(v1, v2) (v1)*(v2)
*/
//MARK: - typedef关键字，取别名
/**
    1、 typedef可以给一个已知的数据类型起别名 (外号)，有时也可用宏定义来代替typedef的功能,但是宏定义是由预处理完成的,而typedef则是在编译时完成的,后者更为灵活方便。
        格式：
            typedef 原类型名 新类型名;
 
        注意:
            1. typedef不仅能给系统原有的数据类型起别名, 也可以给一个自定义的数据类型起别名。
            2. 利用typedef给数据类型起别名, 并不会生成一个新的数据类型, 仅仅是给原有的类型起了一个别名而已。
 
    2、如果是给指向函数的指针起别名, 那么指向函数的指针的指针名称就是它的别名。
        举例：
            typedef int(*functionPotinter)(int , int);
        就相当于
            functionPotinter == int(*functionPotinter)(int , int)
 */

//MARK: - const关键字,类型修饰符,变量的值不能改变。
/**
    1、使用const修饰变量则可以让变量的值不能改变，相当于把变量转成常量。
        常类型是指使用类型修饰符const说明的类型,常类型的变量或对象的值是不能被更新的。
        const写在类型的左边或右边均可，即：int const x=2; 或 const int x=2;
 
    2、const修饰指针：
        先看“*”的位置。
        如果const 在 *的左侧 表示值不能修改,但是指向可以改。
        如果const 在 *的右侧 表示指向不能改,但是值可以改。
        如果在“*”的两侧都有const 标识指向和值都不能改。
 
        举例：
            const int *A; //const修饰指针,A可变,A指向的值不能被修改
            int const *A; //const修饰指向的对象,A可变,A指向的对象不可变
            int *const A; //const修饰指针A, A不可变,A指向的对象可变
            const int *const A;//指针A和A指向的对象都不可变
 
 
 */




