

## 数据的表示
   
    原码，反码，补码的符号位都参与计算，因为原码、反码的符号位参与计算后会失真，所以引入补码。
    计算机默认是用有符号，补码来表示，除非有说明是无符号数，否则默认都是 有符号，补码表示形式。
    正数的补码和原码一样，不变样的。
    
    原码：正数 + 正数。
    反码：正数 + 正数，正数 + 负数。         //计算和结果均为反码，需要转换回原码。
    补码：正数 + 正数，正数 + 负数，负数 + 负数。     //符号位参与计算，计算和结果均为补码，需要转换回原码。

    原码-->反码：正数不变样。负数除符号位外，其余取反。
    原码-->补码：正数不变样。负数除符号位外，其余取反 + 1
    
    浮点数的规格化：规定尾数的最高数位必须是一个有效值。非规格化浮点数要进行规格化操作才能变成规格化浮点数。
    （不管是哪种标准的浮点数表示，规格化的原则都是一样的，就是规定尾数的最高数位必须是一个有效值。所以一定是和1/2挂钩的）
    
        最高有效位，就是表示尾数的 二进制串里 符号位右边 的那位，就是表示数值的最左的那位。
        不同标准的浮点数表示，阶码表示可能不一样(移码或补码)，但是尾数一般都是用补码表示的。
        
        无论是何种标准，都是： 阶码符号 + 阶码 + 尾数符号 + 尾数
        只是不同的标准，阶码占位个数不一样，尾数占位个数不一样，也就是最后的浮点数的精度不一样。
        
        尾数补码规格化之后的表现形式是：1.0XXXXX，因为这个0是最高有效位，变为真值之后就是1了。所以需要通过左右规保证它是0.

    (1)左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算术左移一位，阶码减1（基数为2时）。   （变小，无论正负）
    (2)右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位，阶码加1（基数为2时）。(变大，无论正负)
    
    

## 数据结构
    关键路径：需要穷举每一条路径，可以通过走推，右推的方式找到事件的允许的最早发生时间、允许的最晚结束时间 ==》 最晚发生时间、最早结束时间。
    
        

## 语言

    脚本语言（英語：Scripting language）是为了缩短传统的「编写、编译、链接、运行」（edit-compile-link-run）过程而创建的计算机编程语言。
            早期的脚本语言经常被称为批处理语言或工作控制语言。 一个脚本通常是解释运行而非编译。脚本语言对应的程序是解释程序，不是编译程序。
            
                狭义的脚本语言指为某一特定运行时环境服务的语言，如Bash，Javascript，广义的脚本语言可用来指某些动态的高级语言，如Python、Perl。
                按照普遍接受的定义，脚本语言是指支持脚本、支持为某一特定运行时环境编写的程序、支持自动执行任务的编程语言。
            


