//
//  10,多态原理、初始化、可选链.swift
//  TestSwift
//
//  Created by 蔡天春 on 2020/9/18.
//  Copyright © 2020 蔡天春. All rights reserved.
//

import Foundation


//MARK: - 多态的实现原理
//1、OC： Runtime
//2、C++：虚表（虚函数表）
//3、swift： 类似C++


func testCast(){
    struct Animal2{
        //结构体的方法直接在代码段有位置，直接call就可以了，调用起来比较简单，而class需要维护堆内存，所以要先有一堆复杂的操作，才真正到调用成员方法。
        
        var age = 0
        func speak(){
            print("animal speak")
        }
        
        static func eat(){  //static方法不可以被重写
            print("animal eat")
        }
        subscript(index: Int) -> Int{
            return index
        }
    }

    class Animal{
        
        var age = 0
        func speak(){   //方法可以被子类重写，汇编层就是一段指令，然后被赋值粘贴扩展之类的，都有可能；重写的方法前必须有override关键字
            print("animal speak")
        }
        
       func sleep(){
            print("animal sleep")
        }
        
        func eat(){
            print("animal eat")
        }
        subscript(index: Int) -> Int{
            return index
        }
    }

    class Dog: Animal{
        var weight = 0
        override func speak() {
            print("Dog Speak")
        }
        override func eat() {
            print("Dog eat!")
        }
    }

    class Eha: Dog{
        var iq = 0
    }


    //多态演示
    var ani = Animal()
    ani.speak()
    ani.eat()

    ani = Dog() //向下转型
    ani.speak()
    ani.eat()

    /*
     内存区域：
     堆空间：分配对戏那个
     全局区域：全局变量，就提供给指令使用的那些全局变量吧
     栈空间：分配给方法
     代码区：存放指令代码
     
     这几个区域在内存中的存放顺序（都是虚拟地址）：代码区、全局区、堆空间、栈空间
     逆向工程（查看内存空间所在）：MachOview TEXT DATA  窥探Mach-o文件
     **/

    //Dog对象在堆空间的内存分布：
    //
    //1、第一个八字节是dog对象的类型信息的指针，metedata是类型信息的意思
    //1.1、类型信息内存里面的内容是，头部分内存是类型信息的表，记录了方法在该内存空间的偏移量等等信息
    //1.2、在类型信息内存块记录的偏移量处，依次类里面定义的方法的指针。
    //1.3、方法的存放顺序依次是：1、重写父类的方法；2、父类的方法；3、子类的方法
    //（注意：重写了的父类的方法其实就是拼凑了汇编的指令，到时把这些指令代码一复制粘贴就是一段逻辑流了呀，
    // 如果重写有调用super，那就把父类的指令复制过来，如果没有写super，那就直接砍掉了呀）
    //


    class Point {
        var x: Int = 12
        var y: Int = 34
        var b = true
        
    }
    class Size{
        var width: Int = 0
        var height: Int = 0
    //    init() { }  //如果你不显示写指定初始化器，那么编译器自动为你生成该初始化器，一旦有写（只要有写），则编译器不再为你自动生成
        init(width: Int, height: Int) {
            self.width = width
            self.height = height
        }
        convenience init() {
            //便捷构造器调用链最终必须要显示先调用指定构造器再初始化属性
            self.init(width: 0,height: 0) //但是如果是只写便捷构造器，那么编译器还是会为你自动生成指定构造器的，前提还是你没有显示写指定构造器
            
        }
        convenience init(width: Int) {
            self.init(width: 0,height: 0)
            self.width = width
            
        }
        convenience init(height: Int){
            self.init(width: 0, height: 0)
            self.height = height
        }
    }

    class Person{
        var age: Int = 0
        init(age: Int) {
            self.age = age
        }
        convenience init() {
            self.init(age: 0)
        }
    }

    class Student: Person {
        var score: Int
        init(age: Int, score: Int) {
            self.score = score  //必须先初始化自身的属性
            super.init(age: age)
        }
    }
    //初始化：
    //初始化器：
    //1、类、结构体、枚举都可以定义初始化器，主要讨论类
    //2、类有两种初始化器：指定初始化器（designated initializer）、便捷初始化器（convenience initializer）
    //3、每一个类至少有一个指定初始化器，指定初始化器是类的主要初始化器。（可以有多个指定构造器）
    //4、指定初始化器必须从它的直系父类中调用父类的指定初始化器
    //5、便捷构造器：调用链最末的便捷构造器也就是最开始执行的便捷构造器，必须要先调用指定构造器；给用户提供了多种选择，使用更加安全（必须初始化再用）。
    //6、指定构造器则刚好和便捷构造器的调用链相反，即子类必须先初始化自己的属性，才可以去调用父类的初始化器。
    //7、指定构造器不能在自身之间相互调用，但是便捷初可以，但是便捷链最末那位必须显示调用指定构造器，而且便捷不能跨辈分调用（即只能调用自身的其他便捷构造器）
    //8、所以便捷构造器的设计是为了便捷用户选择合适的初始化方法（花样初始化），而指定构造器，是主要的初始化构造器，用于完成对属性的实际初始化（朴实的工作）。
    //
    //9、上面的那些设计保证了，用任意的构造器，最终都完整地初始化了实例。保证了安全

    //两段式初始化：
    //两段式初始化，安全检查
    //第一阶段：往上
    //初始化所有存储属性（此阶段是为了安全，为了内存的健壮）
    //1、外层调用指定\便捷初始化构造器
    //2、分配内存给实例，但未初始化（还没有给内存赋值，只是分配空间）
    //3、指定初始化构造器确保当前类定义的存储属性都已经初始化（即在内存空间赋值了，指定初始化器的调用链）
    //4、指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链（记住，子类先初始化自身的属性，才可以去去调用父类的初始化器）
    //5、自此，子类到父类的属性都已经被初始化了

    //第二阶段：往下
    //设置新的存储属性（此阶段是内存比较稳定了，给予用户对实例进行个性化定制操作）
    //1、从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例。这样设计，就是内存分配完善健壮之后，给予用户更多的人性化定制机会。（也是在init方法中，只是比较靠后的位置）
    //2、此时的self才可以使用，也就是必须等所有的属性都被初始化内存完毕之后，self关键字才可以使用
    //3、最终，便捷初始化器的调用链中的每一个便捷初始化器都有机会定制实例，以及使用self（也就是在初始化完全完成之前，给予了更多的机会来定制实例）
    //


    //安全检查
    //1、指定初始化器必须保证先初始化完自身的属性，才能去调用父类的初始化构造器，去初始化父类的属性
    //2、必须先调用父类的指定构造器之后，才可以对父类的属性进行赋值操作（此时父类的属性才被分配内存完善）
    //3、第一阶段结束了之后，实例才被分配内存（并赋值）完善，才可以使用self，实例方法等等。也就是指定初始化器向上链最末那位指定初始化器初始化该层的所有属性之后，实例才完整。


    //重写初始化器（重写就是跨辈分同名同参的意思）
    //1、重写父类的指定初始化器时，要在前面加上override，并且可以把父类的指定构造器重写成子类的便捷构造器，但是该便捷构造器内必须先调用自身的指定构造器
    //2、如果子类写了一个匹配父类便捷初始化器的初始化器，则不需加上override关键字（因为严格来说不是重写）；
    //   因为便捷初始化器不能跨辈分，即便是同名也只是只属于该辈分的便捷构造器（横向）（指定构造器是纵向）；可以理解为便捷构造器是绝对私有的。
    //


    //构造器的自动继承（前提子类有了父类的所有指定初始化器）
    //1、如果子类没有定义任何构造器，则自动继承父类所有的（指定）构造器，也就是自动重写了所有和父类一模一样的构造器。
    //   此时，编译器也不会自动生成无参构造器了（因为有了构造器了）；不然必须显示重写，或者super调用，或者自定义；
    //2、如果子类里面有了（无论是继承还是重写）所有的父类指定初始化器，则编译器也自动帮你写入所有和父类一样的便捷构造器（也可以说是“继承”吧）；
    //   重写也可以是重写子类的便捷构造器
    //3、无论又子类增加了多少便捷初始化器，1、2的自动规则仍然适用（因为便捷是绝对私用的）
}



