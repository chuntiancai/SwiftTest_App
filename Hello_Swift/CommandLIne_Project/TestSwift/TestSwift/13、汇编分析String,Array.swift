//
//  13、汇编分析String,Array.swift
//  TestSwift
//
//  Created by 蔡天春 on 2020/9/21.
//  Copyright © 2020 蔡天春. All rights reserved.
//

import Foundation


func testString(){
    //内存从低到高： 代码区-->常量区-->全局区（数据段）-->堆空间-->栈空间-->动态库

    var str1 = "2346789dag"
    //str1占16个字节，0x6439383736343332，0xea00000000006761这两个是ascii码的值
    //0xea，其中的a是标识该字符串直接放在当前的域的地址空间，a表示字符串的长度（15个字符及以内）
    //类似oc的tagger pointer
    print(MemoryLayout.stride(ofValue: str1))
    var str2 = "096thjbijjjjjjjjjjjjjjjjjjj"
    var str3 = "234567890-0876w456790-89398479"
    //str2: rax，rdx=0xd00000000000001b,0x8000000100000f70   来自于call指令的返回值，rax，rdx，实际是调用了Swift.String.init(...)函数
    //str3: rax，rdx=0xd00000000000001e,0x8000000100000f70
    //0x8000000100000f70决定了字符串的真正地址，0x7fffffffffffffe0 + 字符串的真实地址 = 0x8000000100000f70
    //所以字符串的真实地址 = 0x8000000100000f70 - 0x7fffffffffffffe0
    //所以超过了15个字符就不是直接存在当前的域的地址空间了,所以在汇编层跟15比较决定是否调用函数
    //mov 0x7fffffffffffffe0, %rdx
    print(MemoryLayout.stride(ofValue: str2))


    //MARK: - Mach-o文件，可执行文件
    //在可执行文件加载进内存时，系统根据可执行文件的信息对可执行文件进行处理后加载进虚拟内存，虚拟内存中的排序是：mach-o文件 -> ... -> 动态库
    //虚拟内存里面的内容是可以动态加载的。
    //oc、swift源码经过编译、链接变成mach-o文件，mach-o文件是可执行文件，经过系统转换后加载进内存
    //系统根据mach-o文件的信息，对内存进行分配，执行指令；内存（虚拟内存地址）会有部分存放mach-o文件
    //product下的文件就是mach-o文件，ios系统下的可执行文件。

    //可执行文件就是系统可以直接加载进内存执行的文件，在加载进内存之前，系统会对该文件做一系列的处理，不同系统的处理方式不同
    //machOview软件可以窥探mach-o文件，类似于linux系统下的elf文件，可执行文件描述了代码段，data段（全局区），字符表、汇编代码存放处、常量区等信息，
    //就是操作系统里面的概念。所以ios为string类型开辟了一段专属的内存空间，在可执行文件中会描述这些信息。


    //字面量（literal）
    //如果16个字节能容下字面量，那么就会在当前地址存放该字面量，而不是区常量区或者全局区寻找，超过16个字节的话，
    //就用该16个字节存放指针，去对应的内存区寻找（_TEXT.cstring区）。

    str1.append("G")
    //如果append的长度还能在15个字节内的话，仍然会在当前地址增加该字符
    str2.append("G")
    //如果apeend的长度超过15个字节的话，当前的地址内容是指针，指向堆空间；因为常量区不允许修改，不允许进行append，权限问题（设计如此）。
    //EXEC_BAD_ACCESS如果你尝试访问不该访问的内存，或者尝试对常量区的内存进行修改，就会发生这个错误


    //MARK: - 字符串总结
    //1、字符串长度 <= 0xf，字符串内容直接存放在str1变量的内存中
    //2、字符串长度 > 0xf，字符串内容存放在_TEXT.cstring中（常量区），该地址值就放在str2变量的后8个字节中
    //3、如果append后的字符串长度 <= 0xf，那么直接在变量的内存中进行修改
    //4、如果append后的字符串长度 > 0xf，开辟堆空间，因为不确定以后还是否会修改

    //MARK: - dyld_stub_binder (swift中的符号绑定，符号绑定真实的内存地址，os中的概念)
    //延迟绑定
    //stub：翻译成符号（os中的符号）
    //binder：绑定
    //只会做一次绑定，例如绑定string.init函数，函数名就是符号，绑定就是绑定符号和真实地址（相对虚拟地址），
    //一次绑定之后就记录下来，下次就不用再次绑定了，提高性能。

    //MARK: - Array
    //Array在文档上说是结构体（所以swift对Array进行了值类型的约束），但实际并不是，实际是引用类型
    //1、一个Array变量占用8个字节，所以就不同于普通的结构体，有32个字节来存储描述信息;这8个字节存放的是堆空间的地址值
    //2、数组中的数据存放在堆空间，在堆空间的内容是(都是说的8个字节)： ？-> 引用计数 ->  元素数量 ->  数组容量？ ->  真实数据（1、2、3、4（八个字节一个））

    var arr=[1,2,3,4]

    print(MemoryLayout.stride(ofValue: arr))
    print(MemoryLayout<Array<Int>>.stride)

}
