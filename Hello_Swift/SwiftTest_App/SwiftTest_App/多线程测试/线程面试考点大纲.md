

## 什么是runloop，为什么要设计runloop？
    runloop是iOS中的事件循环机制，即线程能随时响应并处理事件的机制，这种机制要求线程不能退出，而且需要高效的完成事件调度与处理。
    其他语言中也有类似的设计，例如事件循环、消息循环。runloop就相当于一个线程的管理者，给线程分配任务。
    iOS设计RunLoop是为了控制子线程处理应用程序中的事件，包括用户交互、系统消息等，以及管理线程的生命周期，可以保活子线程。
    让子线程可以接收事件，根据不同的状态处理事件，休眠、执行，节省系统资源，提高性能。runloop只是线程的一个参考器。
    
## runloop在编程角度的本质是什么？
    RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，内部是一个死循环函数，使得子线程处于活着状态，
    不停地处于“等待-接收-处理”的循环当中，可以传入参数结束这个循环，退出runloop。
    NSRunLoop对象是基于CFRunLoopRef的封装，NSRunLoop是不安全的，是oc面向对象设计的。CFRunLoopRef是线程安全的，是c语言实现的。
    CFRunLoopRef在C语言底层是一个结构体，记录了runloop的运行模式，定时器，事件源等信息作为成员变量。
    RunLoop是基于线程来管理的，它们一一对应，共同存储在一个全局区的runLoopDict中，线程是key，RunLoop是value。
    
    销毁：系统在创建RunLoop的时候，会注册一个回调，确保线程在销毁的同时，也销毁掉其对应的RunLoop。
        如果runloop中没有事件了，线程没有任务了，那么线程就会退出，然后runloop也会退出，如果想保活，那么就需要往runloop里添加事件，定时器这些。
        注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，
             因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃。

    
## runloop的开启是怎样的？
    主线程的runloop在main函数中开始，使得main函数一直没有退出。子线程的runloop是在子线程的源代码中访问runloop即可开启。

## 为什么只在主线程刷新UI，而不在子线程刷新UI？
    1、UIKit并不是线程安全的类，UI操作涉及到渲染和访问各种View对象的属性。如果在异步操作下进行UI更新，可能会存在读写问题，
        加锁操作又会耗费大量资源并拖慢运行速度。
        读写问题是指数据冲突，比如不同线程访问和修改同一个UI组件的属性，会导致脏数据。
        还有一个是竞态条件问题，无法保证多条线程按照不同的顺序访问同一个UI，产生相同的结果，而在单一线程中可以保证。
        
    2、runloop模式的设计，所有用户UI事件，例如点击屏幕、拖动View都是在主线程中进行传递和处理的，子线程默认没有开启runloop，所以不能处理
       这些用户事件，哪怕开启了，在子线程中处理UI事件也存在同步显示问题，因为子线程的执行不能保证和屏幕的刷新频率是一致的。
       
    3、图像的渲染需要以一定的刷新率（如60帧）在屏幕上同时更新，多线程情况下无法确定这个过程能够实现同步更新。
        子线程在完成任务后，需要将UI的更新提交给主线程的渲染服务进行处理，以确保UI的更新能够正确显示。
        因为子线程的执行顺序和时间片分配是由操作系统的调度算法决定的，无法确定具体执行时间。
        还有就是多个线程访问同一个UI组件导致脏数据的问题等等。



## iOS中的进程与线程
    1、在iOS 中 一个进程就是一个正在运行的一个应用程序(即App)，每一个App（一个进程）都有自己独特的内存和磁盘空间， 别的App（进程）是不允许访问的（越狱不在讨论范围）。
        所以，在iPhone中下载了两种音乐播放器，下载的音乐歌曲却是不能共享的！跟安卓完全不同！
        
### 进程 是系统资源分配和调度的一个独立单位，简单的理解就是用来帮程序占据一定的存储空间、时间片等的资源。 进程拥有自己独立的位置空间，在没有经过进程本身允许的情况下，其他进程不能访问该进程的地址空间，只能通信（如管道）。
    而线程则是cpu调度的基本单位，也就是线程只能访问自身进程里资源，不能夸进程访问，如果跨进程访问，则需要通过进程的允许。

    在 iOS 中  UIApplication  这个 类是 是 进程相关的操作的。比如  进程A（程序A） 调用另外一个进程B（程序B） 。 
    打开iOS 系统的浏览器等 都是 这个类 来负责。
    
    多线程的进程中一个线程崩溃了就会导致进程崩溃，如果是主线程崩溃会导致程序崩溃；
    但是多进程中子进程崩溃了不会影响到其它进程，程序稳定性更好；
    
### 临界资源：一次只允许一个进程使用的资源。
    如果多个进程可以共用一个代码段，那么这个代码段也可以是临界资源。
    
### 临界区：多个进程访问临界资源的那一段代码。
        也就是当进程要去执行临界区这段代码的时候，需要先去检查临界资源能不能用，能用才执行临界区代码，否则不执行临界区代码。
        
        多线程同理：所以多线程的数据冲突就在于控制多个线程如何进入临界区，才不会导致脏数据。例如信号量、管程、PV操作。
        
        信号量：表示的是现有资源的数目
