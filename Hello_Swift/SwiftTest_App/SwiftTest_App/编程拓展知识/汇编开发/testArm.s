
//MARK: - 笔记
/**
    1、汇编代码叫做汇编指令，每一条指令对应一条cpu指令，所以它的语法直接就叫做指令。可以百度一下ARM汇编手册。
        通用寄存器：
            64bit：x0~x28;
            32bit：w0～w28;(在64位中，是x0~x28的低32bit)。 //32bit的cpu的通用寄存器是R0～R28;
            arm64架构中，默认用x0~x7来存放函数的参数，更多的参数用堆栈来进行传递，不分配更多的寄存器。

        程序计数器：pc(program counter)
            用于记录当前指令执行完之后，cpu下一条执行的是那一条指令，类似x86的汇编的ip寄存器。
        堆栈指针：
            sp(stack pointer),栈指针寄存器。
            fp(frame pointer),其实就是x29寄存器；
        链接寄存器：lr(link register)，其实就是x30寄存器；
            存储函数的返回地址，也就是流程下一步的地址。
        程序状态寄存器：
            cpsr(current program status register)
            spsr(saved program status register)
        零寄存器：
            零寄存器的存储的值是零，只读。调试的时候，并不能读取出来xzr、wzr寄存器，但是在汇编代码里可以使用。
            xzr(64bit)
            wzr(32bit,word zero register)
        

    2、OC调用汇编函数的时候，默认在函数名前面加上下划线_,所以你的汇编函数实现的时候，要在函数名前加上下划线。
    3、汇编的注视符号其实是分号;，但是xcode允许双斜线//。
    4、ARM汇编是从右往左赋值的。汇编中，函数返回是空也必须写ret，因为ret是给汇编一个符号参考，汇编本身是没有函数这个概念的。
 
    5、堆栈分配
     5.1、叶子函数，最末端的函数，不再调用其他函数。可以用终端命令将c文件转换为汇编文件。
     5.2、叶子函数调用时的流程：赋值sp寄存器(减法)，sp的值为函数栈的开始地址 --> 执行函数体的代码 --> 最后，还原sp的值(加法) --> 从函数返回。
          栈空间的回收其实只是赋值sp寄存器，并没有对之前栈空间残留的数据进行清零操作。
 
         非叶子函数调用时的流程：
            赋值sp寄存器(减法)，sp的值为函数栈的开始地址 --> 存储当前fp、lr寄存器的值到栈空间内存的末尾 --> 赋新值给fp、lr寄存器 --> 执行函数体的代码 --> 跳转到其他函数中执行 --> 从函数返回到当前fp寄存器指向的地址 --> 还原旧的fp、lr寄存器的值 --> 还原sp寄存器的值(加法)-> 跳回到fp、lr的旧值指向的地址。
            fp、lr寄存器用于现场保护。fp用于保护当前栈空间的定位，lr用于保护上一个函数返回地址的位置。
 */
/***
 
 
.text //放在mach-o文件的.text段
.global _testArmFunc, _testArmAdd, _testArmMemory    //声明_testArmFunc, _testArmAdd为公开的函数。

//MARK: - testArmFunc函数的实现
_testArmFunc:   //汇编函数的声明。

//TODO: ;mov 指令
mov x0, #0x8    // mov指令，赋值指令,从右往左赋值。 汇编语法的立即数需要在前面加上#符号。
mov x1, x0

//TODO: ;add 指令
mov x1, #0x1
mov x2, #0x2
add x0, x1 ,x2      // 也是从右往左相加，x2 + x1 = x0 ，把x1 ,x2里面的数相加赋值给x0

//TODO: ;sub 指令
mov x1, #0x5
mov x2, #0x2
sub x0, x1 ,x2      // 也是从右往左被减，x1 - x2 = x0 ，x2 被x1 减去后赋值给x0

//TODO: ;cmp 指令，比较指令。
/**
    1、cmp指令之后，cpu会根据cpsr的值来判断当前的对比状态。也就是对比结果。所以cpsr寄存器的位就有专用名词，什么标识位，控制位，通用位之类的。
 */
/***
mov x1, #0x1
mov x2, #0x2
cmp x1 ,x2      // 用x1 - x2的值去影响cpsr寄存器，cpu根据cpsr中的值来判断对比的结果。

//TODO: ;b 指令，跳转指令。
/**
    1、跳转到mylabel标签的地址，然后执行mylabel标签下的内容，继续往下走，不回来到跳转前的位置。
    2、b指令也可以根据条件进行跳转，arm64汇编的条件符号有 EQ(相等)、NE(不等)、GT(大于)、GE(大等于)、LT(小于)、LE(小等于)等等。根据cpsr的状态来判断。
 */
/***
mov x0,#0x1
mov x1,#0x1
cmp x0,x1
beq mylabel2
b mylabel   //跳转到mylabel标签的地址，然后执行mylabel标签下的内容。
mov x0, #0x5    //该代码将不会被执行，被b指令跳过了。
mylabel:  //对下面的汇编指令进行标签，标签名是mylabel，可以供当前汇编代码的其他标签体使用。其实汇编里所谓的函数也是这样处理的。
mov x1, #0x6
mylabel2:
mov x1,#0x7

//TODO: ;bl指令,带流程返回的跳转。返回到当前指令的下一条指令地址继续执行。
/**
    1、bl指令需要配合ret指令来使用，单纯有ret指令不会跳回到标签地址的下一条指令地址，而是跳转到未知的地方。
    2、ret指令会让流程返回到lr寄存器存储的地址位置，也就是将lr的值赋值给pc。
    3、bl指令首先将下一条指令的地址存储到lr寄存器中，然后跳转到参数地址，然后ret指令会返回到lr寄存器的地址中。
 */
/***
mycode:
mov x0,#0x1
mov x1,#0x1
ret

bl mycode   //跳转到mycode标签的流程里
mov x2,#0x2

//TODO: ;load指令,ldr、ldur、ldp 从内存中装载数据。
/**
    1、从内存中加载数据，就是从内存地址中读取数据。需要用到内存的地址寻址。
    2、立即寻址、寄存器寻址、寄存器间接寻址、
 */
/***
ldr x0,[x1] //寄存器间接寻址，加载x1寄存起的值代表的地址，再把改地址的值放入到x0寄存器中。

//TODO: ;store 指令,str、stur、stp 往内存中存储数据。
/**
    1、往内存的地址中写入数据。
 */

/***
ret

bl mycode   //跳转到mycode标签的流程里
mov x2,#0x2

ret //返回指令，流程返回到标签地址的下一条指令的地址。




//MARK: - testArmAdd函数的实现。
/**
    1、arm64架构中，默认用x0~x7来存放函数的参数，更多的参数用堆栈来进行传递，不分配更多的寄存器。x0通常用于存放函数的返回值。
 */
/***
_testArmAdd:
add x0, x0 ,x1
ret



//MARK: - testArmMemory函数的实现，内存相关指令。
_testArmMemory:

//TODO: ;load指令,ldr、ldur、ldp 从内存中读取数据。
/**
    1、从内存中加载数据，就是从内存地址中读取数据。需要用到内存的地址寻址。
    2、立即寻址、寄存器寻址、寄存器间接寻址、基址变址寻址
        ldr: 加载内存地址的数据到寄存器。
        ldur:负数立即数寻址。
        ldp:从内存中读取数据，从左到右放到一对寄存器中。
 */
/***
ldr x0,[x1] //寄存器间接寻址，加载x1寄存器的值代表的地址，再把改地址的值放入到x0寄存器中。
ldr x0,[x1 , #0x4] //基址变址寻址，加载（x1寄存器的值 + #0x4）代表的地址，再把改地址的值放入到x0寄存器中。
ldr x0,[x1],#0x8    //基址变址寻址，x0 <- [x1], x1 <- x1 + #0x8,
ldur x0,[x1 , #-0x4]    //基址变址寻址,ldur用于寻址负数立即数寻址。
ldp w0,w1,[x2,#0x8]    //从内存中读取数据，从左到右放到一对寄存器中。p是pair的意思。[x2,#0x8]的低4byte赋值给w0，高4byte赋值给w1。

//TODO: ;store 指令,str、stur、stp 往内存中写入数据。
/**
    1、往内存的地址中写入数据。但是不能将立即数写入到内存中，因为立即数并不知道该立即数要占据多少内存空间，没有指定空间大小。
        sdr: 从寄存器写入数据到内存地址。
        sdur: 负数立即数寻址。
        sdp: 从内存中写入数据到一对寄存器中。
 */
/**
str w0,[x1] //寄存器间接寻址，把w0寄存器的值写入到 x1寄存器的值代表的地址。 是从左到右还是从右到左操作，arm64是不规定的，由具体指令决定。

ret
*/
